load ./data-structures/priority-queue.maude
load ./rule-instance.maude
load ./index.maude
load ./score.maude


fmod TERM-ITEM is
    --- sort for items in the priority queue
    protecting SCORE .
    protecting NAT .
    protecting QID .
    protecting META-LEVEL .

    sort TermItem .

    op <_,_,_,_,_,_,_> : Term Qid Term Term Qid Score Nat -> TermItem [ctor] .
    --- resulting term, rule label, term, constraint, variable prefix, score, depth

    vars T T' I I' T0 T0' : Term .
    vars N N' D D' : Nat .
    vars S S' : Score .
    vars Q Q' L L' : Qid .

    op _<_ : TermItem TermItem -> Bool .
    eq < T, L, T0, I, Q, S, D > < < T', L', T0', I', Q', S', D' > = le(S, S') .

    op _>_ : TermItem TermItem -> Bool .
    eq < T, L, T0, I, Q, S, D > > < T', L', T0', I', Q', S', D' > = le(S, S') .

    op _<=_ : TermItem TermItem -> Bool .
    eq < T, L, T0, I, Q, S, D > <= < T', L', T0', I', Q', S', D' > = le(S, S') .

    op getDepth : TermItem -> Nat .
    eq getDepth(< T, L, T0, I, Q, S, D >) = D .
 
    op getLabel : TermItem -> Qid .
    eq getLabel(< T, L, T0, I, Q, S, D >) = L .

    op getScore : TermItem -> Score .
    eq getScore(< T, L, T0, I, Q, S, D >) = S .
endfm

fmod INDEXED-TERM-SET is
    --- sort for terms maintained for folding purposes
    protecting INDEX .

    protecting META-LEVEL .

    sort IndexedTerm . *** Nat is depth for debugging purpose
    op `{_`,_`,_`,_`} : Term Term Index Nat -> IndexedTerm .

    op createIndex : Term -> Index .

    sort IndexedTermSet .  
    subsort IndexedTerm < IndexedTermSet .

    op empty : -> IndexedTermSet [ctor] .
    op _`,_ : IndexedTermSet IndexedTermSet -> IndexedTermSet [ctor assoc comm id: empty] .

    *** for debugging purpose
    op length : IndexedTermSet -> Nat .
    var IDXT : IndexedTerm .
    var IDXTS : IndexedTermSet .
    eq length(IDXT) = 1 .
    eq length(IDXT, IDXTS) = 1 + length(IDXTS) .
    eq length(empty) = 0 .
endfm

fmod TERM-ITEM-SET is 
    protecting TERM-ITEM .

    sort TermItemSet .
    subsort TermItem < TermItemSet .

    op emptyTermItemSet : -> TermItemSet [ctor] .
    op _;;_ : TermItemSet TermItemSet -> TermItemSet [ctor assoc comm id: emptyTermItemSet] .

    var T : TermItem .
    var TIS : TermItemSet .

    op length : TermItemSet -> Nat .
    eq length(emptyTermItemSet) = 0 .
    eq length(T ;; TIS) = 1 + length(TIS) .
endfm


view TermItem from TOSET<= to TERM-ITEM is
  sort Elt to TermItem .
endv

mod SUBSUMPTION-CHECK is
    protecting INDEXED-TERM-SET .

    op _isSubsumedBy_under_ : IndexedTerm IndexedTermSet Module -> Bool  .
    op _isSubsumedBy_under_ : Term Term Module -> Bool .

    var M : Module .
    vars T T' I I' : Term . var IDX : Index . vars D D' : Nat .
    var IDXT : IndexedTerm . var IDXTS : IndexedTermSet .
    var S : Substitution .

    eq T isSubsumedBy T' under M = metaMatch(M, T', T, nil, 0) =/= noMatch .

    ceq ({T, I, IDX, D}) isSubsumedBy ({T', I', IDX, D'}, IDXTS) under M 
    = true
    if metaMatch(M, T', T, nil, 0) =/= noMatch .

    eq IDXT isSubsumedBy IDXTS under M = false [owise] .
endm

mod RENAME is
    protecting META-LEVEL .
    protecting INDEXED-TERM-SET . 
    protecting CONVERSION .

    vars T I : Term . var IDX : Index . var D : Nat .
    var V : Variable . var C : Constant .
    var F : Qid . var NETL : NeTermList .

    op rename : IndexedTerm -> IndexedTerm .
    eq rename({T, I, IDX, D}) = {rename(T, D), I, IDX, D} .

    op rename : NeTermList Nat -> NeTermList .
    eq rename(V, D) = qid("$" + string(D, 10) + string(V)) . 
    eq rename(C, D) = C .
    eq rename(F[NETL], D) = F[rename(NETL, D)] .
    eq rename((T, NETL), D) = rename(T, D) , rename(NETL, D) .
endm

mod FOLDING-STATE-INSERTION is
    protecting RENAME .
    protecting SUBSUMPTION-CHECK .

    sort InsertStateResult .
    subsort IndexedTermSet < InsertStateResult .

    op subsumed : -> InsertStateResult [ctor] .
    op insertState : Module IndexedTerm IndexedTermSet -> InsertStateResult .
    op insertStateInternal : IndexedTerm IndexedTermSet Bool -> InsertStateResult .

    var M : Module .
    var IDXT : IndexedTerm . var IDXTS : IndexedTermSet .
    vars T I : Term . var IDX : Index . var D : Nat .

    eq insertState(M, IDXT, IDXTS)
    = insertStateInternal(IDXT, IDXTS, IDXT isSubsumedBy IDXTS under M) .

    eq insertStateInternal(IDXT, IDXTS, true) = subsumed .
    eq insertStateInternal({T, I, IDX, D}, IDXTS, false) = rename({T, I, IDX, D}), IDXTS .

endm

mod FOLDING-APPLICATION is
    protecting FOLDING-STATE-INSERTION .
    protecting TERM-ITEM-SET .

    var M : Module .
    var IDXT : IndexedTerm . vars IDXTS IDXTS' IDXTS'' : IndexedTermSet .
    var TI : TermItem .
    vars TIS TIS' : TermItemSet .
    vars T T0 I : Term .
    vars L Q : Qid .
    var S : Score .
    var D : Nat .

    sort FoldingResult .
    op {_,_} : TermItemSet IndexedTermSet -> FoldingResult [ctor] .
    --- filtered, new most general so far

    *** module, children, most general so far
    op applyFolding : Module TermItemSet IndexedTermSet -> FoldingResult .
    op applyFoldingInternal : Module TermItemSet IndexedTermSet TermItem InsertStateResult -> FoldingResult .

    eq applyFolding(M, emptyTermItemSet, IDXTS) = {emptyTermItemSet, IDXTS} .

    eq applyFolding(M, < T, L, T0, 'false.Bool, Q, S, D > ;; TIS, IDXTS) 
    = applyFolding(M, TIS, IDXTS) .

    eq applyFolding(M, < T, L, T0, I, Q, S, D > ;; TIS, IDXTS) 
    = applyFoldingInternal(M, TIS, IDXTS, < T, L, T0, I, Q, S, D >, 
    insertState(M, {T, I, createIndex(T), D}, IDXTS)) .

    eq applyFoldingInternal(M, TIS, IDXTS, TI, subsumed)
    = applyFolding(M, TIS, IDXTS) .

    ceq applyFoldingInternal(M, TIS, IDXTS, TI, IDXTS')
    = {TI ;; TIS', IDXTS''}
    if {TIS', IDXTS''} := applyFolding(M, TIS, IDXTS') .
endm

fmod DEPTH-BOUND is
    protecting NAT .
    sort DepthBound .
    subsort Nat < DepthBound .
    op unlimited : -> DepthBound .

endfm

mod GET-CHILDREN is
    protecting META-LEVEL .
    protecting TERM-ITEM-SET .
    protecting DEPTH-BOUND .

    op getChildStates : Module TermItem VariantOptionSet DepthBound -> TermItemSet [memo] .
    op getChildStatesUpToNth : Module TermItem VariantOptionSet Nat -> TermItemSet .
    op getChildStatesUpToNthInternal : Module TermItem VariantOptionSet Nat NarrowingApplyResult? -> TermItemSet .

    var M : Module .
    var TI : TermItem . 
    var VOS : VariantOptionSet .
    vars T T' T0 I I' : Term .
    var S : Score .
    vars D SOLN : Nat .
    var TY' : Type . 
    var CO : Context . 
    vars L L' Q Q' F : Qid . 
    vars S1 S2 : Substitution .

    eq getChildStates(M, TI, VOS, unlimited) = getChildStatesUpToNth(M, TI, VOS, 0) .
    ceq getChildStates(M, TI, VOS, D) = getChildStatesUpToNth(M, TI, VOS, 0) 
    if getDepth(TI) <= D .
    eq getChildStates(M, TI, VOS, D) = emptyTermItemSet [owise] .

    eq getChildStatesUpToNth(M, < T, L, T0, I, Q, S, D >, VOS, SOLN) 
    = getChildStatesUpToNthInternal(M, < T, L, T0, I, Q, S, D >, VOS, SOLN, metaNarrowingApply(M, T, empty, Q, VOS, SOLN)) .

    eq getChildStatesUpToNthInternal(M, TI, VOS, SOLN, failure) = emptyTermItemSet .
    eq getChildStatesUpToNthInternal(M, TI, VOS, SOLN, failureIncomplete) 
    = emptyTermItemSet [print "incomplete narrowing"] .
    ceq getChildStatesUpToNthInternal(M, < T, L, T0, I, Q, S, D >, VOS, SOLN, 
        {T', TY', CO, L', S1, S2, Q'}) 
    = < T', 
        L',
        applySubstitution(M, T, S1),
        I',
        Q', 
        score(T', D + 1), 
        D + 1 > 
      ;; getChildStatesUpToNth(M, < T, L, T0, I, Q, S, D >, VOS, SOLN + 1) 
    if getTerm(metaReduce(M, 'inv[T'])) =/= 'false.Bool
    /\ I' := getTerm(metaReduce(M, applySubstitution(M, I, S1)))
    /\ I' =/= 'false.Bool .

    eq getChildStatesUpToNthInternal(M, < T, L, T0, I, Q, S, D >, VOS, SOLN, 
        {T', TY', CO, L', S1, S2, Q'}) 
    =  getChildStatesUpToNth(M, < T, L, T0, I, Q, S, D >, VOS, SOLN + 1) 
    [owise] .
endm

mod INVISIBLE-TRANSITION is
    protecting TERM-ITEM-SET .
    protecting SUBSUMPTION-CHECK .
    protecting RENAME .
    protecting RULE-INSTANCE .

    var M : Module . 
    vars T T' T0 T0' I I' : Term .
    vars L L' Q Q' F : Qid . 
    var LS : QidSet . 
    vars S S' : Score .
    vars D D' : Nat .
    vars TI TI' : TermItem . vars TIS MATCHED NMATCHED : TermItemSet .
    var N : Nat .
    var IDXTI : IndexedTermItem .
    var IDXTIS : IndexedTermItemSet .
    var IDX : Index .
    var RIS : RuleInstanceSet .

    sort SplitResult .
    op {_,_} : TermItemSet TermItemSet -> SplitResult [ctor] .

    op applyInvisibleTransitionReduction : Module RuleInstanceSet TermItemSet -> TermItemSet .
    op splitReducible : Module RuleInstanceSet TermItemSet -> SplitResult .
    op removeSubsumed : Module IndexedTermItemSet -> TermItemSet .

    sorts IndexedTermItem IndexedTermItemSet .
    subsort IndexedTermItem < IndexedTermItemSet .

    op emptyIndexedTermItemSet : -> IndexedTermItemSet .
    op {_,_,_} : Index Term TermItem -> IndexedTermItem [ctor] .
    op _;;_ : IndexedTermItemSet IndexedTermItemSet -> IndexedTermItemSet [ctor assoc comm id: emptyIndexedTermItemSet] .

    op createIndex : TermItemSet Nat -> IndexedTermItemSet .
    eq createIndex(emptyTermItemSet, N) = emptyIndexedTermItemSet .
    eq createIndex(< T, L, T0, I, Q, S, D > ;; TIS, N) = 
    {createIndex(T0), rename(T0, N), < T, L, T0, I, Q, S, D >} ;; createIndex(TIS, N + 1) .

    op toTermItemSet : IndexedTermItemSet -> TermItemSet .
    eq toTermItemSet(emptyIndexedTermItemSet) = emptyTermItemSet .
    eq toTermItemSet({IDX, T0, TI} ;; IDXTIS) = TI ;; toTermItemSet(IDXTIS) .

    ceq applyInvisibleTransitionReduction(M, RIS, TIS) = NMATCHED ;; removeSubsumed(M, IDXTIS) 
    if {MATCHED, NMATCHED} := splitReducible(M, RIS, TIS) 
    /\ IDXTIS := createIndex(MATCHED, 0) .

    eq splitReducible(M, RIS, emptyTermItemSet) = {emptyTermItemSet, emptyTermItemSet} .
    ceq splitReducible(M, RIS, < T, L, T0, I, Q, S, D > ;; TIS) 
    = if isRuleInstance(M, RIS, L, T0) then {< T, L, T0, I, Q, S, D > ;; MATCHED, NMATCHED}
      else {MATCHED, < T, L, T0, I, Q, S, D > ;; NMATCHED} fi
    if {MATCHED, NMATCHED} := splitReducible(M, RIS, TIS) .

    op invisibleScore : Qid -> Nat .
    eq invisibleScore('vote-true) = 0 .
    eq invisibleScore('vote-false) = 0 .
    eq invisibleScore('receive-true-vote) = 1 .
    eq invisibleScore('receive-false-vote) = 1 .

    ceq removeSubsumed(M, {IDX, T0, TI}  ;; {IDX, T0', TI'} ;; IDXTIS) 
    = removeSubsumed(M, {IDX, T0', TI'} ;; IDXTIS)
    if TI' <= TI
    /\ T0 isSubsumedBy T0' under M .
    eq removeSubsumed(M, IDXTIS) = toTermItemSet(IDXTIS) [owise] .
endm 

mod HEURISTIC-NARROWING is
    protecting SCORE .
    protecting INDEXED-TERM-SET .
    protecting TERM-ITEM-SET .
    protecting LEFTIST-TREES{TermItem} .
    protecting GET-CHILDREN .
    protecting FOLDING-APPLICATION .
    protecting INVISIBLE-TRANSITION .
    protecting RULE-INSTANCE .

    sort HeuristicNarrowingSearchResult .
    op noSolution : Nat -> HeuristicNarrowingSearchResult [ctor] .
    op sol : Term Score Nat Nat -> HeuristicNarrowingSearchResult [ctor] .
    op createSol : TermItem IndexedTermSet -> HeuristicNarrowingSearchResult .

    var M : Module .
    vars T T' T'' T0 I I' : Term .
    vars N D D' : Nat . var S : Score .
    var VOS : VariantOptionSet .
    vars IDXTS IDXTS' IDXTS'' : IndexedTermSet .
    vars TI SOL : TermItem .
    vars TIS FILTERED CHILDREN : TermItemSet .
    vars L Q : Qid .
    var RIS : RuleInstanceSet .
    var UP : UnificationPair .
    vars QUEUE QUEUE' : LTree{TermItem} .
    var DB : DepthBound .

    eq createSol(< T, L, T0, I, Q, S, D >, IDXTS) = sol(T, S, D, length(IDXTS)) .

    op metaHeuristicNarrowingSearch : 
    Module Term Term RuleInstanceSet VariantOptionSet DepthBound
    -> HeuristicNarrowingSearchResult .

    op metaHeuristicNarrowingSearchInternal : 
    Module Term Term RuleInstanceSet VariantOptionSet DepthBound LTree{TermItem} IndexedTermSet 
    -> HeuristicNarrowingSearchResult .


    op isSolution : Module TermItem Term -> Bool .

    ceq isSolution(M, < T, L, T0, I, Q, S, D >, T') = true
    if UP := metaUnify(M, T =? T', Q, 0) 
    /\ getTerm(metaReduce(M, applySubstitution(M, I, getSubstitution(UP)))) =/= 'false.Bool .

    eq isSolution(M, TI, T') = false [owise] .

    op insert : TermItemSet LTree{TermItem} -> LTree{TermItem} .
    eq insert(emptyTermItemSet, QUEUE) = QUEUE .
    eq insert(TI ;; TIS, QUEUE) = insert(TIS, insert(TI, QUEUE)) .

    eq metaHeuristicNarrowingSearch(M, T, T', RIS, VOS, DB)
    = metaHeuristicNarrowingSearchInternal(M, T, T', RIS, VOS, DB,
    insert(< T, 'none, T, 'initialCond[T], '@, score(T, 0), 0 >, empty), --- dummy values
    empty) .

    ceq metaHeuristicNarrowingSearchInternal(M, T, T', RIS, VOS, DB, QUEUE, IDXTS)
    = createSol(TI, IDXTS) 
    if TI := findMin(QUEUE)
    /\ isSolution(M, TI, T') .

    ceq metaHeuristicNarrowingSearchInternal(M, T, T', RIS, VOS, DB, QUEUE, IDXTS)
    = metaHeuristicNarrowingSearchInternal(M, T, T', RIS, VOS, DB, QUEUE' , IDXTS') 
    if TI := findMin(QUEUE)
    /\ CHILDREN := getChildStates(M, TI, VOS, DB)
    /\ {FILTERED, IDXTS'} := applyFolding(M, 
        applyInvisibleTransitionReduction(M, RIS, CHILDREN), 
        IDXTS)
    /\ QUEUE' := insert(FILTERED, deleteMin(QUEUE)) 
    /\ D := getDepth(TI)
    [owise print "current term item: " TI] .

    eq metaHeuristicNarrowingSearchInternal(M, T, T', RIS, VOS, DB, empty, IDXTS)
    = noSolution(length(IDXTS)) .

endm