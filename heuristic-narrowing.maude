load priority-queue.maude

fmod SCORE is
    protecting META-LEVEL .
    protecting INT .

    vars T T' T'' T''' N : Term .
    vars NETL NETL' : NeTermList .
    vars F Q Q' : Qid . var C : Constant . var X : Variable .

    var D : Nat .

    op score : NeTermList Nat -> Int [memo] .
    op sizeOne : NeTermList -> Int [memo] .
    op sizeNat : Term -> Int [memo] .

    eq score(
        'decideTrue[T, T', T'', T'''], D
    ) = sizeOne((T'', T''')) .
    eq score(
        'decideFalse[T, T', T'', T'''], D
    ) = sizeOne((T'', T''')) .
    eq score(
        'timeoutTrue[T, T', T'', T'''], D
    ) = sizeOne((T'', T''')) .
    eq score(
        'timeoutFalse[T, T', T'', T'''], D
    ) = sizeOne((T'', T''')) .

    eq score(
        '`{_`,_`}[T, NETL], D
    ) = sizeOne(NETL) .

    eq sizeOne('__[NETL]) = sizeOne(NETL) .
    eq sizeOne((T, NETL)) = sizeOne(T) + sizeOne(NETL) .

    eq sizeOne('<_:_|_>[NETL]) 
    = 100 .
    ***= if N == '0.Nat2 or getType(N) == 'Zero2 then 100 else 200 fi .

    eq sizeOne('multicast_from_to_[NETL]) = -1 .
    eq sizeOne(X) = 0 .
    eq sizeOne(empty) = 0 .
    eq sizeOne(T) = 0 [owise] .
endfm


fmod TERM-ITEM is
    protecting META-LEVEL .
    protecting NAT .
    protecting QID .

    sort TermItem .

    op <_,_,_,_,_> : Term Term Qid Nat Nat -> TermItem [ctor] .

    vars T T' I I' : Term .
    vars N N' D D' : Nat .
    vars Q Q' : Qid .

    op _<_ : TermItem TermItem -> Bool .
    eq < T, I, Q, N, D > < < T', I', Q', N', D' > = N <= N' .

    op _>_ : TermItem TermItem -> Bool .
    eq < T, I, Q, N, D > > < T', I', Q', N', D' > = N <= N' .

    op _<=_ : TermItem TermItem -> Bool .
    eq < T, I, Q, N, D > <= < T', I', Q', N', D' > = N <= N' .

endfm

*** to maintain the most general so far
fmod TERM-SET is 
    protecting META-LEVEL .

    sort TermSet .
    subsort Term < TermSet .

    op emptyTermSet : -> TermSet [ctor] .
    op _;;_ : TermSet TermSet -> TermSet [ctor assoc comm id: emptyTermSet] .

    op size : TermSet -> Nat .
    var T : Term .
    var TS : TermSet .
    eq size(T) = 1 .
    eq size(T ;; TS) = 1 + size(TS) .
    eq size(emptyTermSet) = 0 .
endfm

fmod TERM-ITEM-SET is 
    protecting TERM-ITEM .

    sort TermItemSet .
    subsort TermItem < TermItemSet .

    op emptyTermItemSet : -> TermItemSet [ctor] .
    op _;;_ : TermItemSet TermItemSet -> TermItemSet [ctor assoc comm id: emptyTermItemSet] .

    var T : TermItem .
    var TIS : TermItemSet .

    op length : TermItemSet -> Nat .
    eq length(emptyTermItemSet) = 0 .
    eq length(T ;; TIS) = 1 + length(TIS) .
endfm


view TermItem from TOSET<= to TERM-ITEM is
  sort Elt to TermItem .
endv


mod BOUNDED-NARROWING is
    protecting SCORE .
    protecting TERM-SET .
    protecting TERM-ITEM-SET .
    protecting LEFTIST-TREES{TermItem} .
    protecting COUNTER .
    protecting CONVERSION .


    sort BoundedNarrowingSearchResult .
    op noSolution : Nat -> BoundedNarrowingSearchResult [ctor] .
    op sol : TermItem Nat -> BoundedNarrowingSearchResult [ctor] .

    *** module, initial term, goal term, variant option set 
    op metaBoundedNarrowingSearch : Module Term Term VariantOptionSet -> BoundedNarrowingSearchResult .

    *** module, initial term, goal term, variant option set, pending, most general so far
    op metaBoundedNarrowingSearchInternal : Module Term Term VariantOptionSet LTree{TermItem} TermSet -> BoundedNarrowingSearchResult .

    var M : Module .
    vars T T' S I I' : Term .
    vars N D SOLN : Nat .
    var VOS : VariantOptionSet .
    vars TS MOST_GENERAL_SO_FAR MOST_GENERAL_SO_FAR' MOST_GENERAL_SO_FAR'' : TermSet .
    vars TI SOL : TermItem .
    vars TIS FILTERED CHILDREN : TermItemSet .
    var TY' : Type . var CO : Context . vars RULE_LABEL Q Q' F : Qid . vars S1 S2 : Substitution .
    var C : Constant . var NETL : NeTermList .  var B : Bool .
    vars QUEUE QUEUE' : LTree{TermItem} .

    var F' : Qid .
    vars NETL' : NeTermList .

    op _isSubsumedBy_under_ : Term TermSet Module -> Bool  .
    eq T isSubsumedBy emptyTermSet under M = false .
    eq F[NETL] isSubsumedBy F[NETL'] under M = metaMatch(M, F[NETL'], F[NETL], nil, 0) =/= noMatch .
    ceq F[NETL] isSubsumedBy F'[NETL'] under M = false if F =/= F' .
    eq T isSubsumedBy T' under M = false [owise] .
    eq T isSubsumedBy (T' ;; TS) under M = T isSubsumedBy T' under M or T isSubsumedBy TS under M .

    var V : Variable .
    op rename : NeTermList Nat -> NeTermList .
    eq rename(V, N) = qid("$" + string(N, 10) + string(V)) . 
    eq rename(C, N) = C .
    eq rename(F[NETL], N) = F[rename(NETL, N)] .
    eq rename((T, NETL), N) = rename(T, N) , rename(NETL, N) .



    op metaAnd : Term Term -> Term .
    eq metaAnd(T, T') = '_and_[T, T'] .

    ops metaWrapInvariant metaWrapInitialInvariant : Term -> Term .
    eq metaWrapInvariant(T) = 'invariant[T] .
    eq metaWrapInitialInvariant(T) = 'initialInvariant[T] .



    sort InsertStateResult .
    subsort TermSet < InsertStateResult .
    op subsumed : -> InsertStateResult [ctor] .
    op insertState : Module Term Nat TermSet -> InsertStateResult .

    op evict : Module TermSet Term -> TermSet .
    eq evict(M, emptyTermSet, T') = emptyTermSet .
    eq evict(M, T ;; TS, T') = if T isSubsumedBy T' under M then evict(M, TS, T') else T ;; evict(M, TS, T') fi .

*** apply folding 
***(

    eq insertState(M, T, D, TS) = 
        if T isSubsumedBy TS under M
        then subsumed
        else 
        ***TS ;; rename(T, D)
        evict(M, TS, rename(T,D)) ;; rename(T, D)
        fi .
)
    *** do not apply folding
    eq insertState(M, T, D, TS) = TS ;; rename(T, D) .

    op getChildren : Module TermItem VariantOptionSet -> TermItemSet [memo] .
    op getChildrenInternal : Module TermItem VariantOptionSet Nat -> TermItemSet .

    eq getChildren(M, TI, VOS) = getChildrenInternal(M, TI, VOS, 0) .


    ceq getChildrenInternal(M, (< T, I, Q, N, D >), VOS, SOLN) 
    = < T', I', Q', score(T', D + 1), D + 1 > ;; TIS
    if {T', TY', CO, RULE_LABEL, S1, S2, Q'} := metaNarrowingApply(M, T, empty, Q, VOS, SOLN) 
    /\ TIS := getChildrenInternal(M, < T, I, Q, N, D >, VOS, SOLN + 1) 
    /\ I' := getTerm(metaReduce(M, metaAnd(applySubstitution(M, I, S1), metaWrapInvariant(T')))) .

    ceq getChildrenInternal(M, < T, I, Q, N, D >, VOS, SOLN) 
    = emptyTermItemSet
    if metaNarrowingApply(M, T, empty, Q, VOS, SOLN) == failure .

    ceq getChildrenInternal(M, < T, I, Q, N, D >, VOS, SOLN) 
    = emptyTermItemSet
    if metaNarrowingApply(M, T, empty, Q, VOS, SOLN) == failureIncomplete .


    *** filtered children, new most general so far
    sort ProcessChildrenResult .
    op {_,_} : TermItemSet TermSet -> ProcessChildrenResult [ctor] .

    *** module, children, most general so far
    op processChildren : Module TermItemSet TermSet -> ProcessChildrenResult .

    eq processChildren(M, emptyTermItemSet, MOST_GENERAL_SO_FAR) = {emptyTermItemSet, MOST_GENERAL_SO_FAR} .

    ceq processChildren(M, < T, I, Q, N, D > ;; TIS, MOST_GENERAL_SO_FAR) 
    = processChildren(M, TIS, MOST_GENERAL_SO_FAR)
    if insertState(M, T, D, MOST_GENERAL_SO_FAR) == subsumed 
    or I == 'false.Bool .

    ceq processChildren(M, < T, I, Q, N, D > ;; TIS, MOST_GENERAL_SO_FAR) 
    = {< T, I, Q, N, D > ;; FILTERED, MOST_GENERAL_SO_FAR''}
    if MOST_GENERAL_SO_FAR' := insertState(M, T, D, MOST_GENERAL_SO_FAR) 
    /\ I =/= 'false.Bool 
    /\ {FILTERED, MOST_GENERAL_SO_FAR''} := processChildren(M, TIS, MOST_GENERAL_SO_FAR') .


    var UP : UnificationPair .

    op isSolution : Module TermItem Term -> Bool .

    ceq isSolution(M, < T, I, Q, N, D >, T') = true
    if UP := metaUnify(M, T =? T', Q, 0) 
    /\ getTerm(metaReduce(M, applySubstitution(M, I, getSubstitution(UP)))) =/= 'false.Bool .

    eq isSolution(M, TI, T') = false [owise] .


    sort FindSolutionResult .
    op found : TermItem -> FindSolutionResult .
    op notFound : -> FindSolutionResult .
    op findSolution : Module Term TermItemSet -> FindSolutionResult .

    eq findSolution(M, T', emptyTermItemSet) = notFound .

    ceq findSolution(M, T', TI ;; TIS) 
    = found(TI)
    if isSolution(M, TI, T') .

    ceq findSolution(M, T', TI ;; TIS) 
    = findSolution(M, T', TIS) 
    if not isSolution(M, TI, T') .

    op insertAll : TermItemSet LTree{TermItem} -> LTree{TermItem} .
    eq insertAll(emptyTermItemSet, QUEUE) = QUEUE .
    eq insertAll(TI ;; TIS, QUEUE) = insertAll(TIS, insert(TI, QUEUE)) .

    eq metaBoundedNarrowingSearch(M, T, T', VOS)
    = metaBoundedNarrowingSearchInternal(M, T, T', VOS, insert(< T, metaWrapInitialInvariant(T), '@, score(T, 0), 0 >, empty), emptyTermSet) .

    ceq metaBoundedNarrowingSearchInternal(M, T, T', VOS, QUEUE, MOST_GENERAL_SO_FAR)
    = sol(TI, size(MOST_GENERAL_SO_FAR))
    if QUEUE =/= empty 
    /\ TI := findMin(QUEUE)
    /\ isSolution(M, TI, T') .

    ceq metaBoundedNarrowingSearchInternal(M, T, T', VOS, QUEUE, MOST_GENERAL_SO_FAR)
    = metaBoundedNarrowingSearchInternal(M, T, T', VOS, QUEUE', MOST_GENERAL_SO_FAR')
    if QUEUE =/= empty 
    /\ TI := findMin(QUEUE)
    /\ not isSolution(M, TI, T')
    /\ CHILDREN := getChildren(M, TI, VOS)
    /\ {FILTERED, MOST_GENERAL_SO_FAR'} := processChildren(M, CHILDREN, MOST_GENERAL_SO_FAR)
    /\ QUEUE' := insertAll(FILTERED, deleteMin(QUEUE)) [print "TI: " TI] .

    *** the queue is empty
    eq metaBoundedNarrowingSearchInternal(M, T, T', VOS, empty, MOST_GENERAL_SO_FAR)
    = noSolution(size(MOST_GENERAL_SO_FAR)) .

endm