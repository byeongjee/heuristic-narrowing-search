
load term-item.maude


fmod HNR-TOP is
    including STATE .
    sort Top .
    op _||_ : State Bool -> Top [ctor] .
    op bot : -> Top [ctor] .
    eq S:State || false = bot .
endfm


fmod FOLDING-APPLICATION is
    protecting SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .
    protecting SET{IdxTerm} * 
    (op _,_ : Set{IdxTerm} Set{IdxTerm} -> Set{IdxTerm} to _;_) .
    protecting CONVERSION .
    protecting META-LEVEL .

    var M : Module .
    var IT : IdxTerm .
    var ITS : Set{IdxTerm} .
    var TIS : Set{QItem} .
    vars T T' TC TC' COND : Term . 
    var IDX : Index . 
    vars S S' : Score .
    vars D D' N : Nat .
    vars Q Q' F : Qid .
    var V : Variable . 
    var C : Constant .
    var NTL : NeTermList .
    var SUB : Substitution . 

    sort FoldingState .
    op {_,_} : Set{QItem} Set{IdxTerm} -> FoldingState [ctor] .

    --- remove all subsumed items
    op folding : Module Set{QItem} Set{IdxTerm} -> FoldingState .
    eq folding(M, TIS, ITS) = folding(M, {folding(M, TIS), ITS}) .

    op folding : Module FoldingState -> FoldingState .
    ceq folding(M, {[[T',IDX], Q, S, D] ; TIS, [T,IDX] ; ITS}) 
      = folding(M, {TIS, [T,IDX] ; ITS})
     if subsume(M, T, T') .
    eq folding(M, {TIS, ITS}) = {TIS, toIdx(TIS,ITS)} [owise] .

    op folding : Module Set{QItem} -> Set{QItem} .
    ceq folding(M, TIS ; [[T,IDX],Q,S,D] ; [[T',IDX],Q',S',D'])
      = folding(M, TIS ; [[T,IDX],Q,S,D])
     if subsume(M, T, T') .
    eq folding(M, TIS) = TIS [owise] .

    --- addall remaining items (renaming is not needed for matching)
    op toIdx : Set{QItem} Set{IdxTerm} -> Set{IdxTerm} .
    eq toIdx([IT, Q, S, D] ; TIS, ITS)
     = toIdx(TIS, ITS ; IT) .
    eq toIdx(empty, ITS) = ITS .

    op subsume : Module Term Term -> Bool [memo] .
    op subsume : Module Term Term Nat -> Bool .
    op subsume : Module Term Term Nat Substitution? -> Bool .
    eq subsume(M, T, T') = subsume(M, T, T', 0) .
    eq subsume(M, '_||_[T,TC], '_||_[T',TC'], N) 
     = subsume(M, '_||_[T,TC], '_||_[T',TC'], N, metaMatch(M,T,T',nil,N)) .
    eq subsume(M, T, T', N, SUB)
     = if checkCond(M,T,T',SUB)  == 'true.Bool then true
       else subsume(M, T, T', s(N)) fi .
    eq subsume(M, T, T', N, noMatch) = false .

    op checkCond : Module Term Term Substitution -> Term .
    eq checkCond(M, '_||_[T,TC], '_||_[T',TC'], SUB)
     = getTerm(metaReduce(M, '_or_['not_[TC'],applySubstitution(M,TC,SUB)])) .
endfm


fmod NARROWING-TRANSITION is
    protecting META-LEVEL .
    protecting SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .

    var M : Module .
    var OPT : VariantOptionSet .
    vars T TC : Term .
    var IDX : Index . 
    var S : Score .
    vars D N : Nat .
    var TY : Type . 
    var CXT : Context . 
    vars Q L : Qid . 
    vars SUB SUB' : Substitution .
    var RP : ResultPair .
    var NAR : NarrowingApplyResult .
    var TIS : Set{QItem} .

    --- obtain the set of next symbolic states
    op next : Module QItem VariantOptionSet -> Set{QItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat Set{QItem} -> Set{QItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat Set{QItem} NarrowingApplyResult? -> Set{QItem} .

    eq next(M, [[T,IDX],Q,S,D], OPT) = next(M, T, Q, D, OPT, 0, empty) .
    eq next(M, T, Q, D, OPT, N, TIS) 
     = next(M, T, Q, D, OPT, N, TIS, metaNarrowingApply(M,T,empty,Q,OPT,N)) .
    eq next(M, T, Q, D, OPT, N, TIS, NAR) 
     = next(M, T, Q, D, OPT, s(N), TIS ; filter(M,NAR,D)) .
    eq next(M, T, Q, D, OPT, N, TIS, failure) = TIS .

    --- remove invalid states
    op filter : Module NarrowingApplyResult Nat -> Set{QItem} .
    ceq filter(M, {'_||_[T,TC],TY,CXT,L,SUB,SUB',Q}, D) 
      = if getTerm(RP) == 'bot.Top then empty
        else [idxTerm('_||_[T, getTerm(RP)]), Q, score(T,s(D)), s(D)] fi
     if RP := metaReduce(M, '_and_[TC,'inv[T]]) .
    eq filter(M, {'bot.Top,TY,CXT,L,SUB,SUB',Q}, D) = empty .

    ---
    op idxTerm : Term -> IdxTerm .
    eq idxTerm('_||_[T,TC]) = ['_||_[T,TC], index(T)] .

endfm


fmod HEURISTIC-NARROWING-SEARCH is
    protecting SCORE .
    protecting LEFTIST-TREES{QItem<=} .
    protecting NARROWING-TRANSITION .
    protecting FOLDING-APPLICATION .

    var M : Module .
    vars T T' TC : Term .
    vars TG : TermList .
    vars N D : Nat . 
    var S : Score .
    var IDX : Index . 
    var OPT : VariantOptionSet .
    vars ITS ITS' : Set{IdxTerm} .
    vars TI SOL : QItem .
    vars TIS TIS' : Set{QItem} .
    vars Q Q' : Qid .
    var SUB : Substitution . 
    var QUE : LTree{QItem<=} .
    var NQUE : NeLTree{QItem<=} .
    var HC : HNSContext .

    sorts HNSContext HNSState .
    op {_,_,_} : Module Term VariantOptionSet -> HNSContext [ctor] .
    op {_,_} : LTree{QItem<=} Set{IdxTerm} -> HNSState [ctor] .

    op hns : HNSContext Term -> MetaHNSResult .
    eq hns(HC, T) = hnsOuter(HC, {insert(hnsInit(T),empty), empty}) .

    op hnsOuter : HNSContext HNSState -> MetaHNSResult .
    ceq hnsOuter(HC, {NQUE, ITS})
      = if findSol(HC,TI) :: Term 
        then hnsSuccess(findSol(HC,TI), TI, | ITS |) 
        else hnsOuter(HC, hnsInner(HC, {deleteMin(NQUE), ITS}, TI)) fi
     if TI := findMin(NQUE) [print "current term item: " TI] .
    eq hnsOuter(HC, {empty, ITS}) = hnsFailure(| ITS |) .

    op hnsInner : HNSContext HNSState QItem -> HNSState .
   ceq hnsInner({M, T', OPT}, {QUE, ITS}, TI) = {insert(TIS', QUE), ITS'} 
     if {TIS', ITS'} := folding(M, next(M, TI, OPT), ITS) .

    --- initial queue item
    op hnsInit : Term -> QItem .
    eq hnsInit('_||_[T,TC]) = [idxTerm('_||_[T,TC]), '@, score(T,0) ,0] .

    --- hns result
    sorts MetaHNSResult .
    op {_,_,_,_} : Term Score Nat Nat -> MetaHNSResult [ctor] .
    op hnsFailure : Nat -> MetaHNSResult [ctor] .
    op hnsSuccess : Term QItem Nat -> MetaHNSResult .
    eq hnsSuccess(T, TI, N) = {T, getScore(TI), getDepth(TI), N} .

    --- insert a set of items into the queue
    op insert : Set{QItem} LTree{QItem<=} -> LTree{QItem<=} .
    eq insert(empty, QUE) = QUE .
    eq insert(TI ; TIS, QUE) = insert(TIS, insert(TI, QUE)) .

--- check if a goal is reached
    op findSol : HNSContext QItem -> TermList .
    op findSol : Module Term Qid Term Nat -> TermList .
    op findSol : Module Term Qid Term Nat UnificationPair? -> TermList .

    eq findSol({M, T', OPT}, [[T,IDX],Q,S,D]) 
     = findSol(M, T, Q, '_||_[T','$PHI:Bool], 0) .
    eq findSol(M, T, Q, TG, N) 
     = findSol(M, T, Q, TG, N, metaUnify(M, T =? TG, Q, 0)) .
    eq findSol(M, T, Q, TG, N, {'$PHI:Bool <- TC ; SUB, Q'})
     = if TC =/= 'false.Bool then applySubstitution(M,T,SUB) 
       else findSol(M, T, Q, TG, s(N)) fi .
    eq findSol(M, T, Q, TG, N, noUnifier) = empty .

endfm


fmod HEURISTIC-NARROWING-DRIVER is
    including HNR-TOP .
    protecting HEURISTIC-NARROWING-SEARCH .

    var M : Module .
    var OPT : VariantOptionSet .
    var Q : Qid .
    vars ST ST' : State .
    var B : Bool .
    vars N D : Nat . 
    var S : Score .
    vars T : Term .

    sort HNSResult .
    op _states:_(depth:_) : Top Nat Nat -> HNSResult [ctor format (d n d s d d d d)] .
    op noSolution : Nat -> HNSResult [ctor] .

    op heuristic-narrow{_}in_:_=>*_such`that_ : VariantOptionSet Qid State State Bool -> HNSResult .
    eq heuristic-narrow {OPT} in Q : ST =>* ST' such that B
     = prettyPrint([Q], hns({trMod([Q]), upTerm(ST'), OPT}, '_||_[upTerm(ST), upTerm(B)])) .

    op prettyPrint : Module MetaHNSResult -> HNSResult .
    eq prettyPrint(M, {T, S, D, N}) = downTerm(T,bot) states: N (depth: D) .
    eq prettyPrint(M, hnsFailure(N)) = noSolution(N) .

    --- a utility module
    op trMod : Module -> Module .
    eq trMod(M)
     = (mod qid("#NEW#" + string(getName(M))) is 
          including getName(M) .
          including 'HNR-TOP .
          sorts none .  none none none none none 
        endm) .
endfm

