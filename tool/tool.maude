
load term-item.maude


fmod HNR-TOP is
    including STATE .
    sort Top .
    op _||_ : State Bool -> Top [ctor] .
    op bot : -> Top [ctor] .
    eq S:State || false = bot .
endfm


fmod HNS-CONFIG is
    protecting META-LEVEL .
    protecting LEFTIST-TREES{QItem<=} .
    protecting SET{IdxTerm} * 
    (op _,_ : Set{IdxTerm} Set{IdxTerm} -> Set{IdxTerm} to _;_) .

    sorts HNSContext HNSState .
    op {_,_} : Module VariantOptionSet -> HNSContext [ctor] .
    op {_,_} : LTree{QItem<=} Set{IdxTerm} -> HNSState [ctor] .
endfm


fmod FOLDING-APPLICATION is
    protecting HNS-CONFIG .
    protecting SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .
    protecting CONVERSION .

    var M : Module .
    var OPT : VariantOptionSet .
    var IT : IdxTerm .
    var ITS : Set{IdxTerm} .
    var TIS : Set{QItem} .
    vars T T' TC TC' COND : Term . 
    var IDX : Index . 
    vars S S' : Score .
    vars D D' N : Nat .
    vars Q Q' F : Qid .
    var V : Variable . 
    var C : Constant .
    var NTL : NeTermList .
    var SUB : Substitution . 

    sort FoldingState .
    op {_,_} : Set{QItem} Set{IdxTerm} -> FoldingState [ctor] .

    --- remove all subsumed items
    op folding : HNSContext Set{QItem} Set{IdxTerm} -> FoldingState .
    eq folding({M,OPT}, TIS, ITS) = folding(M, {folding(M, TIS), ITS}) .

    op folding : Module FoldingState -> FoldingState .
    ceq folding(M, {[[T',IDX], Q, S, D] ; TIS, [T,IDX] ; ITS}) 
      = folding(M, {TIS, [T,IDX] ; ITS})
     if subsume(M, T, T') .
    eq folding(M, {TIS, ITS}) = {TIS, toIdx(TIS,ITS)} [owise] .

    op folding : Module Set{QItem} -> Set{QItem} .
    ceq folding(M, TIS ; [[T,IDX],Q,S,D] ; [[T',IDX],Q',S',D'])
      = folding(M, TIS ; [[T,IDX],Q,S,D])
     if subsume(M, T, T') .
    eq folding(M, TIS) = TIS [owise] .

    --- add all remaining items (renaming is not needed for matching)
    op toIdx : Set{QItem} Set{IdxTerm} -> Set{IdxTerm} .
    eq toIdx([IT, Q, S, D] ; TIS, ITS)
     = toIdx(TIS, ITS ; IT) .
    eq toIdx(empty, ITS) = ITS .

    op subsume : Module Term Term -> Bool [memo] .
    op subsume : Module Term Term Nat -> Bool .
    eq subsume(M, T, T') = subsume(M, T, T', 0) .
    ceq subsume(M, '_||_[T,TC], '_||_[T',TC'], N) 
      = if checkCond(M, TC, TC', SUB)  == 'true.Bool then true
        else subsume(M, T, T', s(N)) fi
     if SUB := metaMatch(M,T,T',nil,N) .
    eq subsume(M, T, T', N) = false [owise] .

    op checkCond : Module Term Term Substitution -> Term .
    eq checkCond(M, TC, TC', SUB)
     = getTerm(metaReduce(M, '_or_['not_[TC'],applySubstitution(M,TC,SUB)])) .
endfm


fmod NARROWING-TRANSITION is
    protecting HNS-CONFIG .
    protecting SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .

    var M : Module .
    var OPT : VariantOptionSet .
    vars T T' T1 : Term .
    var IDX : Index . 
    var S : Score .
    vars D N : Nat .
    var TY : Type . 
    var CXT : Context . 
    vars Q L : Qid . 
    vars SUB SUB' : Substitution .
    var RP : ResultPair .
    var NAR : NarrowingApplyResult .
    var TIS : Set{QItem} .
    var HC : HNSContext .

    --- obtain the set of next symbolic states
    op next : HNSContext QItem -> Set{QItem} .
    eq next(HC, [[T,IDX],Q,S,D]) = next(HC, T, Q, D, 0, empty) .

    op next : HNSContext Term Qid Nat Nat Set{QItem} -> Set{QItem} .
    ceq next({M,OPT}, T, Q, D, N, TIS) 
      = next({M,OPT}, T, Q, D, s(N), TIS ; filter(M,NAR,D))
     if NAR := metaNarrowingApply(M, T, empty, Q, OPT, N) .
    eq next(HC, T, Q, D, N, TIS) = TIS [owise] .

    --- remove invalid states
    op filter : Module NarrowingApplyResult Nat -> Set{QItem} .
    ceq filter(M, {'_||_[T,T'],TY,CXT,L,SUB,SUB',Q}, D) 
      = if T1 == 'bot.Top then empty
        else [['_||_[T,T1], index(T)], Q, score(T,s(D)), s(D)] fi
     if T1 := getTerm(metaReduce(M, '_and_[T','inv[T]])) .
    eq filter(M, {'bot.Top,TY,CXT,L,SUB,SUB',Q}, D) = empty .
endfm


fmod HEURISTIC-NARROWING-SEARCH is
    protecting SCORE .
    protecting NARROWING-TRANSITION .
    protecting FOLDING-APPLICATION .

    var M : Module .
    vars T T' TC : Term .
    vars N D : Nat . 
    var S : Score .
    var IDX : Index . 
    var OPT : VariantOptionSet .
    vars ITS ITS' : Set{IdxTerm} .
    var TI : QItem .
    vars TIS TIS' : Set{QItem} .
    vars Q Q' : Qid .
    var SUB : Substitution . 
    var QUE : LTree{QItem<=} .
    var NQUE : NeLTree{QItem<=} .
    var HC : HNSContext .

    --- hns result
    sorts MetaHNSResult .
    op hnsFailure : Nat -> MetaHNSResult [ctor] .
    op hnsSuccess : Term QItem Nat -> MetaHNSResult [ctor] .

    op hns : HNSContext Term Term -> MetaHNSResult .
    eq hns(HC, T, T') = hnsOuter(HC, T', {insert(hnsInit(T),empty), empty}) .

    op hnsOuter : HNSContext Term HNSState -> MetaHNSResult .
    ceq hnsOuter(HC, T', {NQUE, ITS})
      = if findSol(HC,T',TI) :: Term 
        then hnsSuccess(findSol(HC,T',TI), TI, | ITS |) 
        else hnsOuter(HC, T', hnsInner(HC, {deleteMin(NQUE), ITS}, TI)) fi
     if TI := findMin(NQUE) [print "current term item: " TI] .
    eq hnsOuter(HC, T', {empty, ITS}) = hnsFailure(| ITS |) .

    op hnsInner : HNSContext HNSState QItem -> HNSState .
   ceq hnsInner(HC, {QUE, ITS}, TI) = {insertAll(TIS', QUE), ITS'} 
     if {TIS', ITS'} := folding(HC, next(HC, TI), ITS) .

    --- initial queue item
    op hnsInit : Term -> QItem .
    eq hnsInit('_||_[T,TC]) = [['_||_[T,TC], index(T)], '@, score(T,0) ,0] .

    --- insert a set of items into the queue
    op insertAll : Set{QItem} LTree{QItem<=} -> LTree{QItem<=} .
    eq insertAll(empty, QUE) = QUE .
    eq insertAll(TI ; TIS, QUE) = insertAll(TIS, insert(TI, QUE)) .

--- check if a goal is reached
    op findSol : HNSContext Term QItem -> TermList .
    op findSol : Module Term Qid Term Nat -> TermList .

    eq findSol({M,OPT}, T', [[T,IDX],Q,S,D]) = findSol(M, T, Q, T', 0) .
    ceq findSol(M, T, Q, T', N) 
      = if TC =/= 'false.Bool then applySubstitution(M,T,SUB) 
        else findSol(M, T, Q, T', s(N)) fi
     if {'PHI:Bool <- TC ; SUB, Q'} := metaUnify(M, T =? T', Q, N) .
    eq findSol(M, T, Q, T', N) = empty [owise] .
endfm


fmod HEURISTIC-NARROWING-DRIVER is
    including HNR-TOP .
    protecting HEURISTIC-NARROWING-SEARCH .

    var M : Module .
    var OPT : VariantOptionSet .
    var Q : Qid .
    vars ST ST' : State .
    var B : Bool .
    vars N D : Nat . 
    var S : Score .
    vars T T' T1 : Term .
    var TI : QItem .
    var HC : HNSContext .
    var H : Header .
    vars IL IL' : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .

    sort HNSResult .
    op _states:_(depth:_) : Top Nat Nat -> HNSResult [ctor format (d n d s d d d d)] .
    op noSolution : Nat -> HNSResult [ctor] .

    op heuristic-narrow{_}in_:_=>*_such`that_ : VariantOptionSet Qid State State Bool -> HNSResult .
   ceq heuristic-narrow {OPT} in Q : ST =>* ST' such that B
     = prettyPrint(hns(HC, T, T'))
     if HC := {addImports((including 'HNR-TOP .), upModule(Q,false)), OPT}
     /\ T  := '_||_[upTerm(ST),  upTerm(B)]
     /\ T' := '_||_[upTerm(ST'), 'PHI:Bool] .

    ---
    op prettyPrint : MetaHNSResult -> HNSResult .
    eq prettyPrint(hnsSuccess(T,TI,N)) 
     = downTerm(T,bot) states: N (depth: getDepth(TI)) .
    eq prettyPrint(hnsFailure(N)) = noSolution(N) .

    ---
    op addImports : ImportList Module -> Module .
    eq addImports(IL', mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm)
     = (mod H is IL IL' sorts SS . SSDS OPDS MAS EQS RLS endm) .
endfm

