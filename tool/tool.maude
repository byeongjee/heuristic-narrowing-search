
load term-item.maude


fmod HNR-TOP is
    including STATE .
    sort Top .
    op _||_ : State Bool -> Top [ctor] .
    op bot : -> Top [ctor] .
    eq S:State || false = bot .
endfm


fmod SUBSUMPTION is
    protecting SET{IdxTerm} * 
    (op _,_ : Set{IdxTerm} Set{IdxTerm} -> Set{IdxTerm} to _;_) .
    protecting META-LEVEL .

    var M : Module .
    vars T T' TC TC' COND : Term . 
    var IDX : Index . 
    vars D D' N : Nat .
    var IT : IdxTerm . 
    var ITS : Set{IdxTerm} .
    var SUB : Substitution . 

    op subsumedBy : Module IdxTerm Set{IdxTerm} -> Bool  .
    ceq subsumedBy(M, [T,IDX, D], [T',IDX,D'] ; ITS) = true
     if checkImpl(M, T, T', 0) .
    eq subsumedBy(M, IT, ITS) = false [owise] .

    op checkImpl : Module Term Term Nat -> Bool .
    ceq checkImpl(M, '_||_[T,TC], '_||_[T',TC'], N) = 
       if getTerm(metaReduce(M, COND)) == 'true.Bool then true
       else checkImpl(M, '_||_[T,TC], '_||_[T',TC'], s(N)) fi 
     if SUB := metaMatch(M, T', T, nil, N) 
     /\ COND := '_or_['not_[TC], applySubstitution(M, TC', SUB)] .
    eq checkImpl(M, T, T', N) = false [owise] .
endfm


fmod FOLDING-APPLICATION is
    protecting SUBSUMPTION .
    protecting SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .
    protecting CONVERSION .

    var M : Module .
    var IDX : Index . 
    var IT : IdxTerm . 
    vars ITS ITS' ITS'' : Set{IdxTerm} .
    var TI : QItem .
    vars TIS TIS' : Set{QItem} .
    vars T TC : Term .
    var S : Score .
    var D : Nat .
    vars Q F : Qid .
    var V : Variable . 
    var C : Constant .
    var NTL : NeTermList .

    --- filtered, new most general so far
    sort FoldingResult .
    op {_,_} : Set{QItem} Set{IdxTerm} -> FoldingResult [ctor] .

    *** module, children, most general so far, resulting children
    op applyFolding : Module Set{QItem} Set{IdxTerm} -> FoldingResult .
    op applyFolding : Module Set{QItem} Set{IdxTerm} Set{QItem} -> FoldingResult .

    eq applyFolding(M, TIS, ITS) = applyFolding(M, TIS, ITS, empty) .

    eq applyFolding(M, ['_||_[T,TC], Q, S, D] ; TIS, ITS, TIS') 
    = if subsumedBy(M, ['_||_[T,TC], index(T), D], ITS)
      then applyFolding(M, TIS, ITS, TIS')
      else applyFolding(M, TIS, ['_||_[rename(T,D),rename(TC,D)], index(T), D] ; ITS, 
                       ['_||_[T,TC], Q, S, D] ; TIS') fi .
    eq applyFolding(M, empty, ITS, TIS') = {TIS', ITS} .

    --- rename variables
    op rename : NeTermList Nat -> NeTermList .
    eq rename(V, D) = renameVar(V, D) .
    eq rename(C, D) = C .
    eq rename(F[NTL], D) = F[rename(NTL, D)] .
    eq rename((T, NTL), D) = rename(T, D) , rename(NTL, D) .

    op renameVar : Variable Nat -> Variable [memo] .
    eq renameVar(V, D) = qid("$" + string(D, 10) + string(V)) . 
endfm


fmod NARROWING-TRANSITION is
    protecting META-LEVEL .
    protecting SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .

    var M : Module .
    var OPT : VariantOptionSet .
    vars TT T TC : Term .
    var S : Score .
    vars D N : Nat .
    var TY : Type . 
    var CXT : Context . 
    vars Q L : Qid . 
    vars SUB SUB' : Substitution .
    var RP : ResultPair .
    var NAR : NarrowingApplyResult .
    var TIS : Set{QItem} .

    --- obtain the set of next symbolic states
    op next : Module QItem VariantOptionSet -> Set{QItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat Set{QItem} -> Set{QItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat Set{QItem} NarrowingApplyResult? -> Set{QItem} .

    eq next(M, [TT,Q,S,D], OPT) = next(M, TT, Q, D, OPT, 0, empty) .
    eq next(M, TT, Q, D, OPT, N, TIS) 
     = next(M, TT, Q, D, OPT, N, TIS, metaNarrowingApply(M,TT,empty,Q,OPT,N)) .
    eq next(M, TT, Q, D, OPT, N, TIS, NAR) 
     = next(M, TT, Q, D, OPT, s(N), TIS ; filter(M,NAR,D)) .
    eq next(M, TT, Q, D, OPT, N, TIS, failure) = TIS .

    --- remove invalid states
    op filter : Module NarrowingApplyResult Nat -> Set{QItem} .
    ceq filter(M, {'_||_[T,TC],TY,CXT,L,SUB,SUB',Q}, D) 
      = if getTerm(RP) == 'bot.Top then empty
        else ['_||_[T, getTerm(RP)], Q, score(T,s(D)), s(D)] fi
     if RP := metaReduce(M, '_and_[TC,'inv[T]]) .
    eq filter(M, {'bot.Top,TY,CXT,L,SUB,SUB',Q}, D) = empty .
endfm


fmod HEURISTIC-NARROWING-SEARCH is
    protecting SCORE .
    protecting LEFTIST-TREES{QItem<=} .
    protecting NARROWING-TRANSITION .
    protecting FOLDING-APPLICATION .

    sort MetaHNSResult .
    op failure : Nat -> MetaHNSResult [ctor] .
    op {_,_,_,_} : Term Score Nat Nat -> MetaHNSResult [ctor] .

    var M : Module .
    vars TT TG T T' TC : Term .
    vars N D D' : Nat . 
    var S : Score .
    var OPT : VariantOptionSet .
    vars ITS ITS' ITS'' : Set{IdxTerm} .
    vars TI SOL : QItem .
    vars TIS TIS' : Set{QItem} .
    vars Q Q' : Qid .
    var SUB : Substitution . 
    var QUE : LTree{QItem<=} .

    op metaHNS : Module Term Term Term VariantOptionSet -> MetaHNSResult .
    op metaHNS : Module Term Term VariantOptionSet LTree{QItem<=} Set{IdxTerm} -> MetaHNSResult .
    op metaHNS : Module Term Term VariantOptionSet LTree{QItem<=} Set{IdxTerm} QItem -> MetaHNSResult .
    op metaHNS : Module Term Term VariantOptionSet LTree{QItem<=} FoldingResult -> MetaHNSResult .

    eq metaHNS(M, T, T', TC, OPT)
     = metaHNS(trMod(M), T, T', OPT, 
               insert(['_||_[T,TC], '@, score(T,0), 0], empty), empty) .

    eq metaHNS(M, T, T', OPT, QUE, ITS)
     = if QUE == empty then failure(| ITS |)
       else metaHNS(M, T, T', OPT, QUE, ITS, findMin(QUE)) fi .

    ceq metaHNS(M, T, T', OPT, QUE, ITS, TI)
      = if TT =/= 'bot.Top then {TT, getScore(TI), getDepth(TI), | ITS |}
        else metaHNS(M, T, T', OPT, deleteMin(QUE), 
                     applyFolding(M, next(M,TI,OPT), ITS)) fi
     if TT := checkSol(M, TI, T') [print "current term item: " TI] .

    eq metaHNS(M, T, T', OPT, QUE, {TIS, ITS})
     = metaHNS(M, T, T', OPT, insert(TIS,QUE), ITS) .

    --- check if a goal is reached
    op checkSol : Module QItem Term -> Term .
    op checkSol : Module Term Qid Term Nat -> Term .
    op checkSol : Module Term Qid Term Nat UnificationPair? -> Term .

    eq checkSol(M, [TT,Q,S,D], T') 
     = checkSol(M, TT, Q, '_||_[T','$PHI:Bool], 0) .
    eq checkSol(M, TT, Q, TG, N) 
     = checkSol(M, TT, Q, TG, N, metaUnify(M, TT =? TG, Q, 0)) .
    eq checkSol(M, TT, Q, TG, N, {'$PHI:Bool <- TC ; SUB, Q'})
     = if TC =/= 'false.Bool then applySubstitution(M,TT,SUB) 
       else checkSol(M, TT, Q, TG, s(N)) fi .
    eq checkSol(M, TT, Q, TG, N, noUnifier) = 'bot.Top .

    --- insert a set of items into the queue
    op insert : Set{QItem} LTree{QItem<=} -> LTree{QItem<=} .
    eq insert(empty, QUE) = QUE .
    eq insert(TI ; TIS, QUE) = insert(TIS, insert(TI, QUE)) .

    --- a utility module
    op trMod : Module -> Module .
    eq trMod(M)
     = (mod qid("#NEW#" + string(getName(M))) is 
          including getName(M) .
          including 'HNR-TOP .
          sorts none .  none none none none none 
        endm) .
endfm


fmod HEURISTIC-NARROWING-DRIVER is
    including HNR-TOP .
    protecting HEURISTIC-NARROWING-SEARCH .

    var M : Module .
    var OPT : VariantOptionSet .
    var Q : Qid .
    vars ST ST' : State .
    var B : Bool .
    vars N D : Nat . 
    var S : Score .
    vars T : Term .

    sort HNSResult .
    op _states:_(depth:_) : Top Nat Nat -> HNSResult [ctor format (d n d s d d d d)] .
    op noSolution : Nat -> HNSResult [ctor] .

    op heuristic-narrow{_}in_:_=>*_such`that_ : VariantOptionSet Qid State State Bool -> HNSResult .
    eq heuristic-narrow {OPT} in Q : ST =>* ST' such that B
     = prettyPrint([Q], metaHNS([Q], upTerm(ST), upTerm(ST'), upTerm(B), OPT)) .

    op prettyPrint : Module MetaHNSResult -> HNSResult .
    eq prettyPrint(M, {T, S, D, N}) = downTerm(T,bot) states: N (depth: D) .
    eq prettyPrint(M, failure(N)) = noSolution(N) .
endfm

