
load term-item.maude


fmod SUBSUMPTION is
    protecting SET{IndexedTerm} * 
    (op _,_ : Set{IndexedTerm} Set{IndexedTerm} -> Set{IndexedTerm} to _;_) .
    protecting META-LEVEL .

    var M : Module .
    vars T T' TC TC' COND : Term . 
    var IDX : Index . 
    vars D D' N : Nat .
    var IT : IndexedTerm . 
    var ITS : Set{IndexedTerm} .
    var SUB : Substitution . 

    op subsumedBy : Module IndexedTerm Set{IndexedTerm} -> Bool  .
    ceq subsumedBy(M, {T, TC ,IDX, D}, {T', TC', IDX, D'} ; ITS) = true
     if checkImpl(M, T, TC, T', TC', 0) .
    eq subsumedBy(M, IT, ITS) = false [owise] .

    op checkImpl : Module Term Term Term Term Nat -> Bool .
    ceq checkImpl(M, T, TC, T', TC', N) = 
       if getTerm(metaReduce(M, COND)) == 'true.Bool then true
       else checkImpl(M, T, TC, T', TC', s(N)) fi 
     if SUB := metaMatch(M, T', T, nil, N) 
     /\ COND := '_or_['not_[TC], applySubstitution(M, TC', SUB)] .
    eq checkImpl(M, T, TC, T', TC', N) = false [owise] .
endfm


fmod FOLDING-APPLICATION is
    protecting SUBSUMPTION .
    protecting SET{TermItem} *
    (op _,_ : Set{TermItem} Set{TermItem} -> Set{TermItem} to _;_) .
    protecting CONVERSION .

    var M : Module .
    var IDX : Index . 
    var IT : IndexedTerm . 
    vars ITS ITS' ITS'' : Set{IndexedTerm} .
    var TI : TermItem .
    vars TIS TIS' : Set{TermItem} .
    vars T TC : Term .
    var S : Score .
    var D : Nat .
    vars Q F : Qid .
    var V : Variable . 
    var C : Constant .
    var NTL : NeTermList .

    --- filtered, new most general so far
    sort FoldingResult .
    op {_,_} : Set{TermItem} Set{IndexedTerm} -> FoldingResult [ctor] .

    *** module, children, most general so far, resulting children
    op applyFolding : Module Set{TermItem} Set{IndexedTerm} Set{TermItem} -> FoldingResult .
    eq applyFolding(M, [T, TC, Q, S, D] ; TIS, ITS, TIS') 
    = if subsumedBy(M, {T, TC, index(T), D}, ITS)
      then applyFolding(M, TIS, ITS, TIS')
      else applyFolding(M, TIS, {rename(T,D), rename(TC,D), index(T), D} ; ITS, 
                        [T, TC, Q, S, D] ; TIS') fi .
    eq applyFolding(M, empty, ITS, TIS') = {TIS', ITS} .

    --- rename variables
    op rename : NeTermList Nat -> NeTermList .
    eq rename(V, D) = renameVar(V, D) .
    eq rename(C, D) = C .
    eq rename(F[NTL], D) = F[rename(NTL, D)] .
    eq rename((T, NTL), D) = rename(T, D) , rename(NTL, D) .

    op renameVar : Variable Nat -> Variable [memo] .
    eq renameVar(V, D) = qid("$" + string(D, 10) + string(V)) . 
endfm


fmod NARROWING-TRANSITION is
    protecting META-LEVEL .
    protecting SET{TermItem} *
    (op _,_ : Set{TermItem} Set{TermItem} -> Set{TermItem} to _;_) .


    var M : Module .
    var OPT : VariantOptionSet .
    vars TG TT T TC TC' : Term .
    var S : Score .
    vars D N : Nat .
    var TY : Type . 
    var CXT : Context . 
    vars Q Q' L : Qid . 
    vars SUB SUB' : Substitution .
    var RP : ResultPair .
    var NAR : NarrowingApplyResult .

    --- obtain the set of next symbolic states
    op next : Module TermItem VariantOptionSet -> Set{TermItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat -> Set{TermItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat NarrowingApplyResult? -> Set{TermItem} .

    eq next(M, [T,TC,Q,S,D], OPT) = next(M, '_||_[T,TC], Q, D, OPT, 0) .
    eq next(M, TT, Q, D, OPT, N) 
     = next(M, TT, Q, D, OPT, N, metaNarrowingApply(M,TT,empty,Q,OPT,N)) .
    eq next(M, TT, Q, D, OPT, N, NAR) 
     = filter(M, NAR, D) ; next(M, TT, Q, D, OPT, s(N)) .
    eq next(M, TT, Q, D, OPT, N, failure) = empty .

    --- remove invalid states
    op filter : Module NarrowingApplyResult Nat -> Set{TermItem} .
    ceq filter(M, {'_||_[T,TC],TY,CXT,L,SUB,SUB',Q}, D) 
      = if getTerm(RP) == 'bot.Top then empty
        else [T, getTerm(RP), Q, score(T,s(D)), s(D)] fi
     if RP := metaReduce(M, '_and_[TC,'inv[T]]) .
    eq filter(M, {'bot.Top,TY,CXT,L,SUB,SUB',Q}, D) = empty .

    --- check if a goal is reached
    op checkSol : Module TermItem Term -> TermList .
    op checkSol : Module Term Term Qid Term Nat -> TermList .
    op checkSol : Module Term Term Qid Term Nat UnificationPair? -> TermList .

    eq checkSol(M, [T,TC,Q,S,D], TG) = checkSol(M, T, TC, Q, TG, 0) .
    eq checkSol(M, T, TC, Q, TG, N) 
     = checkSol(M, T, TC, Q, TG, N, metaUnify(M, '_||_[T,TC] =? '_||_[TG,'$PHI:Bool], Q, 0)) .
    eq checkSol(M, T, TC, Q, TG, N, {'$PHI:Bool <- TC' ; SUB, Q'})
     = if TC' =/= 'false.Bool then '_||_[applySubstitution(M,T,SUB), TC']
       else checkSol(M, T, TC, Q, TG, s(N)) fi .
    eq checkSol(M, T, TC, Q, TG, N, noUnifier) = empty .
endfm


fmod HEURISTIC-NARROWING-SEARCH is
    protecting SCORE .
    protecting LEFTIST-TREES{TermItem<=} .
    protecting NARROWING-TRANSITION .
    protecting FOLDING-APPLICATION .

    sort MetaHNSResult .
    op failure : Nat -> MetaHNSResult [ctor] .
    op {_,_,_,_,_} : Term Term Score Nat Nat -> MetaHNSResult [ctor] .

    var M : Module .
    vars T T' TC TC' : Term .
    var TR : TermList .
    vars N D D' : Nat . 
    var S : Score .
    var OPT : VariantOptionSet .
    vars ITS ITS' ITS'' : Set{IndexedTerm} .
    vars TI SOL : TermItem .
    vars TIS TIS' : Set{TermItem} .
    vars Q : Qid .
    var QUE : LTree{TermItem<=} .
    var NQUE : NeLTree{TermItem<=} .

    op metaHeuristicNarrowingSearch : Module Term Term Term VariantOptionSet -> MetaHNSResult .
    eq metaHeuristicNarrowingSearch(M, T, T', TC, OPT)
     = metaHNSAux(trMod(M), T, T', OPT, insert([T, TC, '@, score(T, 0), 0], empty), empty) .

    op metaHNSAux : Module Term Term VariantOptionSet LTree{TermItem<=} Set{IndexedTerm} -> MetaHNSResult .

    ceq metaHNSAux(M, T, T', OPT, NQUE, ITS)
      = if TR =/= empty then success(TR, TI, | ITS |)
        else metaHNSAux2(M, T, T', OPT, NQUE, ITS, TI) fi
     if TI := findMin(NQUE)  
     /\ TR := checkSol(M, TI, T') .

    eq metaHNSAux(M, T, T', OPT, empty, ITS) = failure(| ITS |) .
 
    op metaHNSAux2 : Module Term Term VariantOptionSet LTree{TermItem<=} Set{IndexedTerm} TermItem -> MetaHNSResult .
    ceq metaHNSAux2(M, T, T', OPT, NQUE, ITS, TI)
      = metaHNSAux(M, T, T', OPT, insert(TIS, deleteMin(NQUE)), ITS')
     if {TIS, ITS'} := applyFolding(M, next(M, TI, OPT), ITS, empty)
       [owise print "current term item: " TI] .

    ---
    op success : Term TermItem Nat -> MetaHNSResult .
    eq success('_||_[T', TC'], [T,TC,Q,S,D], N) = {T', TC', S, D, N} .

    --- insert a set of items into the queue
    op insert : Set{TermItem} LTree{TermItem<=} -> LTree{TermItem<=} .
    eq insert(empty, QUE) = QUE .
    eq insert(TI ; TIS, QUE) = insert(TIS, insert(TI, QUE)) .

    --- 
    op trMod : Module -> Module .
    eq trMod(M)
     = (mod qid("#NEW#" + string(getName(M))) is 
          including getName(M) .
          sorts 'Top .  
          none 
          (op 'bot : nil -> 'Top [ctor] .)
          (op '_||_ : 'State 'Bool -> 'Top [ctor] .) 
          none 
          (eq '_||_['S:State, 'false.Bool] = 'bot.Top [none] .)
          none 
        endm) .
endfm


fmod HEURISTIC-NARROWING-DRIVER is
    including STATE .
    protecting HEURISTIC-NARROWING-SEARCH .

    var M : Module .
    var OPT : VariantOptionSet .
    var Q : Qid .
    vars ST ST' : State .
    var B : Bool .
    vars N D : Nat . 
    var S : Score .
    vars T T' : Term .

    sort State? .
    subsort State < State? .
    op errS : -> State? [ctor] .

    sort Bool? .
    subsort Bool < Bool? .
    op errB : -> Bool? [ctor] .

    sort HNSResult .
    op _||_states:_(depth:_) : State Bool Nat Nat -> HNSResult [ctor format (d d d n d s d d d d)] .
    op noSolution : Nat -> HNSResult [ctor] .

    op heuristic-narrow{_}in_:_=>*_such`that_ : VariantOptionSet Qid State State Bool -> HNSResult .
    eq heuristic-narrow {OPT} in Q : ST =>* ST' such that B
     = prettyPrint([Q], metaHeuristicNarrowingSearch([Q], upTerm(ST), upTerm(ST'), upTerm(B), OPT)) .

    op prettyPrint : Module MetaHNSResult -> HNSResult .
    eq prettyPrint(M, {T, T', S, D, N})
     = downTerm(T,errS) || downTerm(T',errB) states: N (depth: D) .
    eq prettyPrint(M, failure(N)) = noSolution(N) .
endfm

