
load term-item.maude


fmod HNR-TOP is
    including STATE .
    sort Top .
    op _||_ : State Bool -> Top [ctor] .
    op bot : -> Top [ctor] .
    eq S:State || false = bot .
endfm


fmod SUBSUMPTION is
    protecting SET{IndexedTerm} * 
    (op _,_ : Set{IndexedTerm} Set{IndexedTerm} -> Set{IndexedTerm} to _;_) .
    protecting META-LEVEL .

    var M : Module .
    vars T T' TC TC' COND : Term . 
    var IDX : Index . 
    vars D D' N : Nat .
    var IT : IndexedTerm . 
    var ITS : Set{IndexedTerm} .
    var SUB : Substitution . 

    op subsumedBy : Module IndexedTerm Set{IndexedTerm} -> Bool  .
    ceq subsumedBy(M, {T, TC ,IDX, D}, {T', TC', IDX, D'} ; ITS) = true
     if checkImpl(M, T, TC, T', TC', 0) .
    eq subsumedBy(M, IT, ITS) = false [owise] .

    op checkImpl : Module Term Term Term Term Nat -> Bool .
    ceq checkImpl(M, T, TC, T', TC', N) = 
       if getTerm(metaReduce(M, COND)) == 'true.Bool then true
       else checkImpl(M, T, TC, T', TC', s(N)) fi 
     if SUB := metaMatch(M, T', T, nil, N) 
     /\ COND := '_or_['not_[TC], applySubstitution(M, TC', SUB)] .
    eq checkImpl(M, T, TC, T', TC', N) = false [owise] .
endfm


fmod FOLDING-APPLICATION is
    protecting SUBSUMPTION .
    protecting SET{TermItem} *
    (op _,_ : Set{TermItem} Set{TermItem} -> Set{TermItem} to _;_) .
    protecting CONVERSION .

    var M : Module .
    var IDX : Index . 
    var IT : IndexedTerm . 
    vars ITS ITS' ITS'' : Set{IndexedTerm} .
    var TI : TermItem .
    vars TIS TIS' : Set{TermItem} .
    vars T TC : Term .
    var S : Score .
    var D : Nat .
    vars Q F : Qid .
    var V : Variable . 
    var C : Constant .
    var NTL : NeTermList .

    --- filtered, new most general so far
    sort FoldingResult .
    op {_,_} : Set{TermItem} Set{IndexedTerm} -> FoldingResult [ctor] .

    *** module, children, most general so far, resulting children
    op applyFolding : Module Set{TermItem} Set{IndexedTerm} Set{TermItem} -> FoldingResult .
    eq applyFolding(M, [T, TC, Q, S, D] ; TIS, ITS, TIS') 
    = if subsumedBy(M, {T, TC, index(T), D}, ITS)
      then applyFolding(M, TIS, ITS, TIS')
      else applyFolding(M, TIS, {rename(T,D), rename(TC,D), index(T), D} ; ITS, 
                        [T, TC, Q, S, D] ; TIS') fi .
    eq applyFolding(M, empty, ITS, TIS') = {TIS', ITS} .

    --- rename variables
    op rename : NeTermList Nat -> NeTermList .
    eq rename(V, D) = renameVar(V, D) .
    eq rename(C, D) = C .
    eq rename(F[NTL], D) = F[rename(NTL, D)] .
    eq rename((T, NTL), D) = rename(T, D) , rename(NTL, D) .

    op renameVar : Variable Nat -> Variable [memo] .
    eq renameVar(V, D) = qid("$" + string(D, 10) + string(V)) . 
endfm


fmod NARROWING-TRANSITION is
    protecting META-LEVEL .
    protecting SET{TermItem} *
    (op _,_ : Set{TermItem} Set{TermItem} -> Set{TermItem} to _;_) .


    var M : Module .
    var OPT : VariantOptionSet .
    vars TT T TC : Term .
    var S : Score .
    vars D N : Nat .
    var TY : Type . 
    var CXT : Context . 
    vars Q L : Qid . 
    vars SUB SUB' : Substitution .
    var RP : ResultPair .
    var NAR : NarrowingApplyResult .

    --- obtain the set of next symbolic states
    op next : Module TermItem VariantOptionSet -> Set{TermItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat -> Set{TermItem} .
    op next : Module Term Qid Nat VariantOptionSet Nat NarrowingApplyResult? -> Set{TermItem} .

    eq next(M, [T,TC,Q,S,D], OPT) = next(M, '_||_[T,TC], Q, D, OPT, 0) .
    eq next(M, TT, Q, D, OPT, N) 
     = next(M, TT, Q, D, OPT, N, metaNarrowingApply(M,TT,empty,Q,OPT,N)) .
    eq next(M, TT, Q, D, OPT, N, NAR) 
     = filter(M, NAR, D) ; next(M, TT, Q, D, OPT, s(N)) .
    eq next(M, TT, Q, D, OPT, N, failure) = empty .

    --- remove invalid states
    op filter : Module NarrowingApplyResult Nat -> Set{TermItem} .
    ceq filter(M, {'_||_[T,TC],TY,CXT,L,SUB,SUB',Q}, D) 
      = if getTerm(RP) == 'bot.Top then empty
        else [T, getTerm(RP), Q, score(T,s(D)), s(D)] fi
     if RP := metaReduce(M, '_and_[TC,'inv[T]]) .
    eq filter(M, {'bot.Top,TY,CXT,L,SUB,SUB',Q}, D) = empty .
endfm


fmod HEURISTIC-NARROWING-SEARCH is
    protecting SCORE .
    protecting LEFTIST-TREES{TermItem<=} .
    protecting NARROWING-TRANSITION .
    protecting FOLDING-APPLICATION .

    sort MetaHNSResult .
    op failure : Nat -> MetaHNSResult [ctor] .
    op {_,_,_,_} : Term Score Nat Nat -> MetaHNSResult [ctor] .

    var M : Module .
    vars TT TG T T' TC : Term .
    vars N D D' : Nat . 
    var S : Score .
    var OPT : VariantOptionSet .
    vars ITS ITS' ITS'' : Set{IndexedTerm} .
    vars TI SOL : TermItem .
    vars TIS TIS' : Set{TermItem} .
    vars Q Q' : Qid .
    var SUB : Substitution . 
    var QUE : LTree{TermItem<=} .
    var NQUE : NeLTree{TermItem<=} .

    op metaHeuristicNarrowingSearch : Module Term Term Term VariantOptionSet -> MetaHNSResult .
    eq metaHeuristicNarrowingSearch(M, T, T', TC, OPT)
     = metaHNSAux(trMod(M), T, T', OPT, insert([T, TC, '@, score(T,0), 0], empty), empty) .

    op metaHNSAux : Module Term Term VariantOptionSet LTree{TermItem<=} Set{IndexedTerm} -> MetaHNSResult .

    ceq metaHNSAux(M, T, T', OPT, NQUE, ITS)
      = if TT =/= 'bot.Top then {TT, getScore(TI), getDepth(TI), | ITS |}
        else metaHNSAux2(M, T, T', OPT, NQUE, ITS, TI) fi
     if TI := findMin(NQUE)  
     /\ TT := checkSol(M, TI, T') .

    eq metaHNSAux(M, T, T', OPT, empty, ITS) = failure(| ITS |) .
 
    op metaHNSAux2 : Module Term Term VariantOptionSet LTree{TermItem<=} Set{IndexedTerm} TermItem -> MetaHNSResult .
    ceq metaHNSAux2(M, T, T', OPT, NQUE, ITS, TI)
      = metaHNSAux(M, T, T', OPT, insert(TIS, deleteMin(NQUE)), ITS')
     if {TIS, ITS'} := applyFolding(M, next(M, TI, OPT), ITS, empty)
       [owise print "current term item: " TI] .

    --- check if a goal is reached
    op checkSol : Module TermItem Term -> Term .
    op checkSol : Module Term Qid Term Nat -> Term .
    op checkSol : Module Term Qid Term Nat UnificationPair? -> Term .

    eq checkSol(M, [T,TC,Q,S,D], T') 
     = checkSol(M, '_||_[T,TC], Q, '_||_[T','$PHI:Bool], 0) .
    eq checkSol(M, TT, Q, TG, N) 
     = checkSol(M, TT, Q, TG, N, metaUnify(M, TT =? TG, Q, 0)) .
    eq checkSol(M, TT, Q, TG, N, {'$PHI:Bool <- TC ; SUB, Q'})
     = if TC =/= 'false.Bool then applySubstitution(M,TT,SUB) 
       else checkSol(M, TT, Q, TG, s(N)) fi .
    eq checkSol(M, TT, Q, TG, N, noUnifier) = 'bot.Top .

    --- insert a set of items into the queue
    op insert : Set{TermItem} LTree{TermItem<=} -> LTree{TermItem<=} .
    eq insert(empty, QUE) = QUE .
    eq insert(TI ; TIS, QUE) = insert(TIS, insert(TI, QUE)) .

    --- 
    op trMod : Module -> Module .
    eq trMod(M)
     = (mod qid("#NEW#" + string(getName(M))) is 
          including getName(M) .
          including 'HNR-TOP .
          sorts none .  none none none none none 
        endm) .
endfm


fmod HEURISTIC-NARROWING-DRIVER is
    including HNR-TOP .
    protecting HEURISTIC-NARROWING-SEARCH .

    var M : Module .
    var OPT : VariantOptionSet .
    var Q : Qid .
    vars ST ST' : State .
    var B : Bool .
    vars N D : Nat . 
    var S : Score .
    vars T : Term .

    sort HNSResult .
    op _states:_(depth:_) : Top Nat Nat -> HNSResult [ctor format (d n d s d d d d)] .
    op noSolution : Nat -> HNSResult [ctor] .

    op heuristic-narrow{_}in_:_=>*_such`that_ : VariantOptionSet Qid State State Bool -> HNSResult .
    eq heuristic-narrow {OPT} in Q : ST =>* ST' such that B
     = prettyPrint([Q], metaHeuristicNarrowingSearch([Q], upTerm(ST), upTerm(ST'), upTerm(B), OPT)) .

    op prettyPrint : Module MetaHNSResult -> HNSResult .
    eq prettyPrint(M, {T, S, D, N}) = downTerm(T,bot) states: N (depth: D) .
    eq prettyPrint(M, failure(N)) = noSolution(N) .
endfm

