--- The variant of the onethirdrule that embeds invariants in the model, 
--- which can be tested using the "vu-narrow" command."
--- static invisible transition-based reduction is applied

load ./sorts/fvp-nat.maude
load ./sorts/sorts.maude
load ../heuristic-search/state.maude


mod CONFIGURATION is
    protecting NODE .
    protecting INITIAL-SORTS .

    sorts Attribute AttributeSet InitialAttribute InitialAttributeSet .
    subsort Attribute < AttributeSet .
    subsort InitialAttributeSet < AttributeSet .

    sorts None Object Msg ObjectSet MsgSet Configuration InitialObject InitialObjectSet .

    subsort MsgSet ObjectSet < Configuration .
    subsort InitialObject < Object InitialObjectSet < ObjectSet .
    subsort None < ObjectSet MsgSet .
    subsort Msg < MsgSet .

    op <_:_|_> : Oid Cid IU1234S -> InitialObject [ctor object] .
    op <_:_|_> : Oid Cid U1234S -> Object [ctor object] .
    op none : -> None [ctor] .
    op __ : None None -> None [ctor config assoc comm id: none] .
    op __ : InitialObjectSet InitialObjectSet -> InitialObjectSet [ctor config assoc comm id: none] .
    op __ : ObjectSet ObjectSet -> ObjectSet [ctor config assoc comm id: none] .
    op __ : MsgSet MsgSet -> MsgSet [ctor config assoc comm id: none] .
    op __ : Configuration Configuration -> Configuration [ctor config assoc comm id: none] .

endm


fmod MESSAGE-CONTENT is
    protecting FVP-NAT .
    sort MsgContent . 

    ops trueVote falseVote : Nat -> MsgContent [ctor] .
endfm



mod MULTICAST is 
  including CONFIGURATION .
  including MESSAGE-CONTENT .

  op multicast_from_to_ : MsgContent Oid OidSet -> Msg [ctor] .
  var MC : MsgContent . var SENDER : Oid .
  eq multicast MC from SENDER to none = none [variant] .
endm

mod GLOBAL is
    protecting CONFIGURATION .
    protecting FVP-NAT .
    including STATE .
    protecting BOOL .

    sort InternalState .

    op {_,_,_} : Nat OidSet Configuration -> InternalState [ctor] .
    op check : [Bool] InternalState -> State [ctor] .
    op ready : InternalState -> State [ctor] .
endm

mod INV is
    protecting GLOBAL .
    protecting BOOL .

    op invariant : InternalState -> Bool .
    var IS : InternalState .
    var B : [Bool] .
    ceq check(B, IS) = ready(IS) if B =/= false .
endm


mod ONETHIRDRULE-VU-NARROW is
    including GLOBAL .
    protecting VALUE .
    protecting MULTICAST .
    protecting BOOL .
    protecting FVP-NAT .
    protecting FVP-BOOL .
    protecting INV .

    vars O O' : Oid . vars CONF : Configuration . var M : Msg . var C : Cid .
    vars OIDS OIDS' : OidSet . 
    var R N N' VT VF VA : Nat .
    var Z : Zero .
    vars V : Value .

    rl [loss] : 
    ready({N, OIDS, M CONF})
    =>
    check(invariant({N, OIDS, CONF}),
        {N, OIDS, CONF}) [narrowing] .

    rl [vote-true-new] : 
    ready({N, O ; OIDS,
        < O : Node | status : (0, init), value : true, decision : nil, votes : (VT, VF, VA) > 
        CONF
    })
    =>
    check(
        invariant({N, O ; OIDS,
        < O : Node | status : (0, waiting), value : true, decision : nil, votes : (s VT, VF, s VA) > 
        (multicast trueVote(0) from O to OIDS)
        CONF
    }),
        {N, O ; OIDS,
        < O : Node | status : (0, waiting), value : true, decision : nil, votes : (s VT, VF, s VA) > 
        (multicast trueVote(0) from O to OIDS)
        CONF
    }) [narrowing] .

    rl [vote-true-existing] : 
    ready({N, O ; OIDS,
        < O : Node | status : (s R, init), value : true, decision : nil, votes : (VT, VF, VA) > 
        CONF
    })
    =>
    check(
        invariant({N, O ; OIDS,
        < O : Node | status : (s R, waiting), value : true, decision : nil, votes : (s VT, VF, s VA) > 
        (multicast trueVote(s R) from O to OIDS)
        CONF
    }),
        {N, O ; OIDS,
        < O : Node | status : (s R, waiting), value : true, decision : nil, votes : (s VT, VF, s VA) > 
        (multicast trueVote(s R) from O to OIDS)
        CONF
    }) [narrowing] .


    rl [vote-false-new] : 
    ready({N, O ; OIDS,
        < O : Node | status : (0, init), value : false, decision : nil, votes : (VT, VF, VA) > 
        CONF
    })
    =>
    check(
        invariant({N, O ; OIDS,
        < O : Node | status : (0, waiting), value : false, decision : nil, votes : (VT, s VF, s VA) > 
        (multicast falseVote(0) from O to OIDS)
        CONF
    }),
        {N, O ; OIDS,
        < O : Node | status : (0, waiting), value : false, decision : nil, votes : (VT, s VF, s VA) > 
        (multicast falseVote(0) from O to OIDS)
        CONF
    }) [narrowing] .

    rl [vote-false-existing] : 
    ready({N, O ; OIDS,
        < O : Node | status : (s R, init), value : false, decision : nil, votes : (VT, VF, VA) > 
        CONF
    })
    =>
    check(
        invariant({N, O ; OIDS,
        < O : Node | status : (s R, waiting), value : false, decision : nil, votes : (VT, s VF, s VA) > 
        (multicast falseVote(s R) from O to OIDS)
        CONF
    }),
        {N, O ; OIDS,
        < O : Node | status : (s R, waiting), value : false, decision : nil, votes : (VT, s VF, s VA) > 
        (multicast falseVote(s R) from O to OIDS)
        CONF
    }) [narrowing] .


    rl [receive-true-vote] :
    ready({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S > 
        (multicast trueVote(R) from O' to (O ; OIDS'))
        CONF
    }) =>
    check(invariant({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (s VT, VF, s VA), ATTS:U2S > 
        (multicast trueVote(R) from O' to OIDS')  
        CONF
    }),
    {N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (s VT, VF, s VA), ATTS:U2S > 
        (multicast trueVote(R) from O' to OIDS')  
        CONF
    }) [narrowing] .

    rl [receive-false-vote] :
    ready({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S > 
        (multicast falseVote(R) from O' to (O ; OIDS'))
        CONF
    }) =>
    check(invariant({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, s VF, s VA), ATTS:U2S > 
        (multicast falseVote(R) from O' to OIDS')  
        CONF
    }), {N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, s VF, s VA), ATTS:U2S > 
        (multicast falseVote(R) from O' to OIDS')  
        CONF
    }) [narrowing] .


    op decideTrue : Bool' Nat OidSet Object Configuration -> InternalState [ctor] .
    op decideFalse : Bool' Nat OidSet Object Configuration -> InternalState [ctor] .
    op updateTrue : Bool' Nat OidSet Object Configuration -> InternalState [ctor] .
    op updateFalse : Bool' Nat OidSet Object Configuration -> InternalState [ctor] .

    ops _<=_ _<_ : Nat Nat -> Bool' .
    eq N <= N N' = true [variant] .
    eq N < N' = s N <= N' [variant] .

    rl [decideTrue-1] :
    ready({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S > 
        CONF
    })
    =>
    check(
        invariant({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >
        CONF}),
    decideTrue(N <= VT,
        N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >,
        CONF
    ))
    [narrowing] .

    eq [decideTrue-2] :
    decideTrue(true,
        N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, ATTS:U24S >,
        CONF
    ) 
    =
    {N, OIDS,
        < O : Node | status : (R, finished), decision : true, ATTS:U24S  >
        CONF
    } [variant] .

    rl [decideFalse-1] :
    ready({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >
        CONF
    })
    =>
    check(
        invariant({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >
        CONF})
        ,decideFalse(N <= VF,
        N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >,
        CONF
    )) [narrowing] .

    eq [decideFalse-2] :
    decideFalse(true,
        N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U24S >,
        CONF)
    =
    {N, OIDS,
        < O : Node | status : (R, finished), decision : false, votes : (VT, VF, VA), ATTS:U24S >
        CONF
    } [variant] .

    rl [updateTrue-1] : 
    ready({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >
        CONF
    })
    =>
    check(
        invariant({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >
        CONF}),
        updateTrue(
        (VT <  N) and (N <= VA) and (VF <= VT),
        N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA), ATTS:U2S >,
        CONF
    )) [narrowing] .

    eq [updateTrue-2] : 
    updateTrue(
        true,
        N, OIDS,
        < O : Node | status : (R, waiting), value : V, decision : nil, votes : (VT, VF, VA) >,
        CONF
    )
    =
    {N, OIDS,
        < O : Node | status : (s R, init), value : true, decision : nil, votes : (0, 0, 0) >
        CONF
    } [variant] .

    rl [updateFalse-1] : 
    ready({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA) >
        CONF
    })
    =>
    check(invariant({N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA) >
        CONF}),
    updateFalse(
        (VF < N) and (N <= VA) and (s VT <= VF),
        N, OIDS,
        < O : Node | status : (R, waiting), decision : nil, votes : (VT, VF, VA) >,
        CONF
    )) [narrowing] .

    eq [updateFalse-2] : 
    updateFalse(
        true,
        N, OIDS,
        < O : Node | status : (R, waiting), value : V, decision : nil, votes : (VT, VF, VA) >,
        CONF
    )
    =
    {N, OIDS,
        < O : Node | status : (s R, init), value : false, decision : nil, votes : (0, 0, 0) >
        CONF
    } [variant] .

endm
